/* generated by Buddy 3.1.0 */

var global = window.global = window;

(function (global) {
  var babelHelpers = global.babelHelpers = {};

  babelHelpers.typeof = function (obj) {
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };

  babelHelpers.classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  babelHelpers.createClass = (function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();

  babelHelpers.defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  babelHelpers.get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  babelHelpers.inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  babelHelpers.possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  babelHelpers.taggedTemplateLiteral = function (strings, raw) {
    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  };
})(typeof global === "undefined" ? self : global);

(function(root) {
	/**
	 * Load or retrieve cached version of requested module with id 'path' or 'path/index'
	 * @param {String} path
	 * @returns {Object}
	 */
	function require (path) {
		// Find in cache
		var m = require.modules[path] || require.modules[path + '/index'];

		if (!m) {
			// Handle versioned modules when called without version number
			var p, idx;
			for (var p in require.modules) {
				if ((idx = p.indexOf('#')) != -1) {
					if (path == p.slice(0, idx)) {
						m = require.modules[p];
						break;
					}
				}
			}
			if (!m) throw new Error("Couldn't find module for: " + path);
		}

		// Instantiate the module if it's export object is not yet defined
		if (!m.exports) {
			// Convert 'lazy' evaluated string to Function
			if ('string' == typeof m) {
				// 'm' is key to raw source
				m = require.modules[path] = new Function('require', 'module', 'exports', require.modules[m]);
			}
			m.exports = {};
			m.filename = path;
			m.call(null, require, m, m.exports);
		}

		// Return the exports object
		return m.exports;
	}

	// Cache of module objects
	require.modules = {};

	/**
	 * Retrieve raw 'lazy' module source
	 * @param {String} path
	 * @returns {String}
	 */
	require.raw = function requireRaw (path) {
		return require.modules['raw:' + path] || '';
	};

	/**
	 * Register a module with id of 'path' and callback of 'fn'
	 * Alternatively accepts 'fn' string for lazy evaluation
	 * @param {String} path
	 * @param {Function|String} fn [signature should be of type (require, module, exports)]
	 */
	require.register = function requireRegister (path, fn) {
		if ('string' == typeof fn) {
			// Store raw source
			var key = 'raw:' + path;
			require.modules[key] = fn;
			require.modules[path] = key;
		} else {
			require.modules[path] = fn;
		}
	};

	// Expose
	root.require = require;

})((typeof window !== 'undefined') ? window : global);
require.register('src/index.js', function(require, module, exports) {
    'use strict'
    
    /**
     * Determine if 'obj1' and 'obj2' are conceptually equal,
     * optionally ignoring properties in 'ignore'
     * @param {Object} obj1
     * @param {Object} obj2
     * @param {Array} [ignore]
     * @param {Debug} [debug]
     * @returns {Boolean}
     */
    ;
    module.exports = function isEqual(obj1, obj2, ignore, debug) {
      ignore = ignore || [];
    
      if (equal(obj1, obj2)) return true;
    
      if (isObject(obj1) && isObject(obj2)) {
        var keys1 = keys(obj1, ignore),
            keys2 = keys(obj2, ignore);
    
        if (keys1.length != keys2.length) return false;
    
        for (var i = 0, n = keys1.length; i < n; i++) {
          var prop = keys1[i],
              val1 = obj1[prop],
              val2 = obj2[prop];
    
          if (!equal(val1, val2)) {
            if (debug) debug('"%s" not equal %s:%s', prop, val1, val2);
            return false;
          }
        }
        return true;
      }
      return false;
    };
    
    /**
     * Determine if 'val1' and 'val2' are equal
     * @param {Object} val1
     * @param {Object} val2
     * @returns {Boolean}
     */
    function equal(val1, val2) {
      var type1 = typeof val1 === 'undefined' ? 'undefined' : babelHelpers.typeof(val1),
          type2 = typeof val2 === 'undefined' ? 'undefined' : babelHelpers.typeof(val2);
    
      // Convert NaN to null
      if (type1 == 'number' && isNaN(val1)) val1 = null;
      if (type2 == 'number' && isNaN(val2)) val2 = null;
    
      return val1 === val2 ||
      // Handle null & undefined
      val1 == null && val2 == null || isEqualArray(val1, val2);
    }
    
    /**
     * Determine if 'obj' is an object
     * @param {Object} obj
     * @returns {Boolean}
     */
    function isObject(obj) {
      var type = typeof obj === 'undefined' ? 'undefined' : babelHelpers.typeof(obj);
    
      return 'object' == type && 'function' != type && !Array.isArray(obj);
    }
    
    /**
     * Retrieve non-ignored keys of 'obj'
     * @param {Object} obj
     * @param {Array} ignore
     * @returns {Array}
     */
    function keys(obj, ignore) {
      return Object.keys(obj).filter(function (key) {
        // Ignore functions
        return 'function' != typeof obj[key] && ! ~ignore.indexOf(key);
      });
    }
    
    /**
     * Determine if arrays 'arr1' and 'arr2' are equal
     * @param {Array} arr1
     * @param {Array} arr2
     * @returns {Boolean}
     */
    function isEqualArray(arr1, arr2) {
      if (Array.isArray(arr1) && Array.isArray(arr2)) {
        var n1 = arr1.length,
            n2 = arr2.length;
    
        if (n1 != n2) return false;
        // Equal if both empty
        if (n1 == 0 && n2 == 0) return true;
    
        // Not equal if items not strictly equal
        for (var i = 0; i < n1; i++) {
          if (arr1[i] !== arr2[i]) return false;
        }
        return true;
      }
      return false;
    }
});
require('src/index.js');